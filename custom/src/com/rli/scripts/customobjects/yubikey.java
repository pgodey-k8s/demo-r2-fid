package com.rli.scripts.customobjects;

import java.io.BufferedReader;
import java.io.InputStreamReader;

import com.rli.slapd.server.LDAPException;
import com.rli.vds.util.InterceptParam;
import com.rli.web.http.service.twofactor.UserDefinedAuthenticator;

import java.net.URL;
import java.net.URLConnection;


import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class yubikey implements UserDefinedAuthenticator {
	private final static Logger log4jLogger = LogManager.getLogger(yubikey.class);
	protected String wsapi_urls[] = {
            "https://api2.yubico.com/wsapi/2.0/verify",
            "https://api.yubico.com/wsapi/2.0/verify",
            "https://api3.yubico.com/wsapi/2.0/verify",
            "https://api4.yubico.com/wsapi/2.0/verify",
            "https://api5.yubico.com/wsapi/2.0/verify"
 		};

	// yubikey OTP validation service
	// 44 characters generated by dongle . 
	public void authenticate(InterceptParam ip) {
		
			// connection to service
			String serviceUrl = ip.getConnectionstringUrl(); // OTP service url
			// should normally come from parameters. Those are required to use yubicloud
			// form registration  to the yubicloud service to get an APIkey:
			// https://upgrade.yubico.com/getapikey/			
			// APIkey -> entered into the datasource username
			// API Secret Key -> entered in the password in the datasource . Not used here 
			// more complex access to the service to avoid tempered info may be developed
			// and use the secretkey 
			String ClientID=ip.getConnectionstringUsername(); // API key
			String secretkey=ip.getConnectionstringPassword();// API secretkey
			
			// parameters to authenticate / verify OTP
			String keyID = ip.getUserid(); // Id (should match first 12 characters of the key)	
			String password = ip.getPassword(); //full password unparsed
			String userDN=ip.getBindDN();
			String token = ip.getProperty(UserDefinedAuthenticator.PROP_TOKENXTRACT); // 44 characters
			String passwordxtract = ip.getProperty(UserDefinedAuthenticator.PROP_PASSWORDXTRACT); // get password after parsing
			String altserviceUrl = ip.getProperty("alturl"); // OTP service url alternate
			ip.setStatusProceed();
			ip.setErrorcodeZero();
			int retrycount=0;
			boolean usev2=false;
				
			log(">>> DN: " + userDN);
			log(">>> keyID: " + keyID);
			log(">>> Token: " + token);
			log(">>> url: " + serviceUrl);
			if (serviceUrl.equalsIgnoreCase("v2")) {
				//use v2 end points , pre-hardcoded
				serviceUrl=wsapi_urls[0];
				altserviceUrl=null;
				usev2=true;
			}
			if (altserviceUrl!=null)
			log(">>> failover url: " + altserviceUrl);
			// verify input parameter to handle the authentication
			if ("".equals(keyID)||"".equals(token) || token.length()<44 || (keyID.length()<12) ){
				//cannot pass identification of key or no token for the authentication
				ip.setStatusFailed();
				ip.setErrorcode(LDAPException.INAPPROPRIATE_AUTHENTICATION);
				ip.setErrormessage("Invalid or Missing key");
				return;
			}
			// verify that the key ID for the user matches the the keyID of the Yubikey dongle 
			if (token.toLowerCase().startsWith(keyID.toLowerCase())){
				 // ok continue to validate the token
			}					
			else
			{
				// the dongle ID don't match the one registered for  that user
				ip.setStatusFailed();
				ip.setErrorcode(LDAPException.INAPPROPRIATE_AUTHENTICATION);
				ip.setErrormessage("User key identifier and Yubikey key identifier mismatch");
				return;
			}
			// Do the validation toward the OTP service
			//http://api.yubico.com/wsapi/verify?id=
			// for v2 include 'nounce'
			String nonce = null;
			String OTPurl = serviceUrl+"?";	
			boolean result = false;
			BufferedReader in =null;
			URL srv = null;
			URLConnection conn = null;
			boolean tryagain=false;
			if (usev2) {
					tryagain=true;
					nonce=java.util.UUID.randomUUID().toString().replaceAll("-", "");
			} else
				if ((altserviceUrl!=null)&& (!"".equals(altserviceUrl)))
				{
					tryagain=true;
				}
			
			try {
				do {
					try {	
						// we may use querystring and clientid to generate signature  
						String querystring="";
						querystring+="id="+ClientID;
						querystring+="&otp="+token;
						if (nonce!=null)						
							querystring+="&nonce="+nonce;
						log(">>> url: " + OTPurl);
						srv = new URL(OTPurl+ querystring);
						conn = srv.openConnection();
						tryagain=false;
					} catch (Exception exx) {
						if (!tryagain)
							throw (exx);
						if (usev2) {
							retrycount++;
							if (retrycount<wsapi_urls.length) {
								OTPurl= wsapi_urls[retrycount]+"?";
								tryagain=true;
							} else tryagain=false;
						}
						else {
						OTPurl=altserviceUrl+"?";
						 tryagain=false;
						}
					}
				} while (tryagain);
				
		        in = new BufferedReader(new InputStreamReader(
		                                conn.getInputStream()));
		        String inputLine;
		        String errmes="";
		        result=true;
		        while ((inputLine = in.readLine()) != null) { 
		        	int ix=inputLine.indexOf("=");
		            if(ix==-1) continue; // Invalid line
		            String key=inputLine.substring(0,ix);
		            String val=inputLine.substring(ix+1);		            
		        	if ("status".equals(key)) {
		            	if (!"OK".equals(val)) {
		            		errmes=val;
		            		result=false;
		            	}
		            }
		        	if ("nonce".equals(key)) {
		        		if (nonce!=null && (!nonce.equals(val))) {
		            		if ("".equals(errmes))
		            			errmes="NONCE_MISMATCH";
		            		result=false;		        			
		        		}
		        	}
		        	if ("otp".equals(key)) {
		        		if (token!=null && (!token.equals(val))) {
		            		if ("".equals(errmes))
		        				errmes="OTP_MISMATCH";
		            		result=false;		        			
		        		}
		        	}
		        }
				if (result) {
					ip.setPassword(passwordxtract); // set password extract part
					ip.setStatusProceed(); // indicate we want to do VDS authentication
				} else {
					ip.setStatusFailed();
					ip.setErrorcode(LDAPException.INVALID_CREDENTIALS);

					ip.setErrormessage("Invalid Yubikey Id or Key not valid -"+errmes);				
				}
				
			} catch (Exception e) {
				ip.setErrorcode(LDAPException.INAPPROPRIATE_AUTHENTICATION);
				ip.setErrormessage(e.toString());
				ip.setStatusFailed();				
			}
			finally
			{
		        if (in!=null) 
		        	try {in.close();} 
		        		catch (Exception exx){}
			}

	}
	
	private static void log(String message) {
		log4jLogger.debug(message);
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
